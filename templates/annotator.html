<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UAV Pose Annotation Tool</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 25px 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header h1 {
            font-size: 28px;
            font-weight: 600;
        }

        .header .user-info {
            font-size: 16px;
            opacity: 0.95;
        }

        .main-content {
            display: flex;
            height: calc(100vh - 150px);
        }

        .sidebar {
            width: 300px;
            background: #f8f9fa;
            border-right: 2px solid #e0e0e0;
            padding: 20px;
            overflow-y: auto;
        }

        .canvas-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 20px;
            position: relative;
        }

        .controls {
            margin-bottom: 20px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        button {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }

        .btn-primary {
            background: #667eea;
            color: white;
        }

        .btn-primary:hover {
            background: #5568d3;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn-success {
            background: #10b981;
            color: white;
        }

        .btn-success:hover {
            background: #059669;
        }

        .btn-warning {
            background: #f59e0b;
            color: white;
        }

        .btn-warning:hover {
            background: #d97706;
        }

        .btn-danger {
            background: #ef4444;
            color: white;
        }

        .btn-danger:hover {
            background: #dc2626;
        }

        .canvas-wrapper {
            flex: 1;
            position: relative;
            background: #000;
            border-radius: 10px;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        canvas {
            cursor: crosshair;
            max-width: 100%;
            max-height: 100%;
        }

        .image-list {
            list-style: none;
        }

        .image-item {
            padding: 12px;
            margin-bottom: 8px;
            background: white;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            border: 2px solid transparent;
            word-break: break-all;
        }

        .image-item:hover {
            background: #f0f0f0;
            transform: translateX(5px);
        }

        .image-item.active {
            background: #667eea;
            color: white;
            border-color: #5568d3;
        }

        .image-item.annotated {
            border-left: 4px solid #10b981;
        }

        .point-legend {
            background: white;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .point-legend h3 {
            margin-bottom: 10px;
            color: #333;
            font-size: 16px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            margin-right: 10px;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .status {
            background: white;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .status h3 {
            margin-bottom: 10px;
            color: #333;
            font-size: 16px;
        }

        .progress-bar {
            width: 100%;
            height: 25px;
            background: #e0e0e0;
            border-radius: 12px;
            overflow: hidden;
            margin-top: 10px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 600;
            font-size: 12px;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            background: white;
            padding: 40px;
            border-radius: 15px;
            max-width: 400px;
            text-align: center;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }

        .modal-content h2 {
            margin-bottom: 20px;
            color: #333;
        }

        .modal-content input {
            width: 100%;
            padding: 15px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 16px;
            margin-bottom: 20px;
        }

        .modal-content input:focus {
            outline: none;
            border-color: #667eea;
        }

        .instructions {
            background: #fff3cd;
            border-left: 4px solid #f59e0b;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .instructions h4 {
            margin-bottom: 10px;
            color: #856404;
        }

        .instructions ol {
            margin-left: 20px;
            color: #856404;
        }

        .instructions li {
            margin-bottom: 5px;
        }

        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #10b981;
            color: white;
            padding: 15px 25px;
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            z-index: 2000;
            display: none;
            animation: slideIn 0.3s;
        }

        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .keyboard-shortcuts {
            background: white;
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
            font-size: 12px;
        }

        .keyboard-shortcuts h4 {
            margin-bottom: 10px;
            color: #333;
        }

        .shortcut {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            color: #666;
        }

        .key {
            background: #e0e0e0;
            padding: 2px 8px;
            border-radius: 4px;
            font-family: monospace;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üõ©Ô∏è ƒ∞HA Poz Etiketleme Aracƒ±</h1>
            <div class="user-info">
                Etiketleyici: <strong id="userName">Y√ºkleniyor...</strong>
            </div>
        </div>

        <div class="main-content">
            <div class="sidebar">
                <div class="status">
                    <h3>üìä ƒ∞lerleme</h3>
                    <p><strong id="annotatedCount">0</strong> / <strong id="totalCount">0</strong> g√∂rsel etiketlendi</p>
                    <div class="progress-bar">
                        <div class="progress-fill" id="progressFill">0%</div>
                    </div>
                </div>

                <div class="point-legend">
                    <h3>üìÅ Klas√∂r</h3>
                    <select id="subfolderSelector" onchange="loadImages(this.value)" style="width: 100%; padding: 8px; border-radius: 5px; border: 1px solid #ddd; margin-bottom: 15px;">
                        <option value="">T√ºm G√∂rseller (Ana Klas√∂r)</option>
                    </select>
                </div>

                <div class="point-legend">
                    <h3>üéØ Anahtar Noktalar (6 nokta)</h3>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #ef4444;"></div>
                        <span>1. Burun Ucu</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #10b981;"></div>
                        <span>2. Sol Kanat Ucu</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #f59e0b;"></div>
                        <span>3. Saƒü Kanat Ucu</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #3b82f6;"></div>
                        <span>4. Kuyruk (G√∂vde)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #a855f7;"></div>
                        <span>5. Kanat K√∂k√º</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #ec4899;"></div>
                        <span>6. Dikey Dengeleyici *</span>
                    </div>
                    <p style="font-size: 11px; color: #666; margin-top: 8px;">* Yoksa gizli olarak i≈üaretle</p>
                </div>

                <div class="instructions">
                    <h4>üìù Talimatlar</h4>
                    <ol>
                        <li>Klas√∂r√º se√ßin (atandƒ±ysa)</li>
                        <li>G√∂rsele tƒ±klayƒ±n (otomatik kilitlenir)</li>
                        <li>üîí = Ba≈ükasƒ± √ºzerinde √ßalƒ±≈üƒ±yor</li>
                        <li>6 noktayƒ± sƒ±rayla yerle≈ütirin</li>
                        <li>Yakƒ±nla≈ütƒ±rma: Fare tekerleƒüi</li>
                        <li>Kaydƒ±rma: Shift+S√ºr√ºkle</li>
                        <li>G√∂r√ºn√ºrl√ºk: Saƒü tƒ±klama</li>
                        <li>Kaydet: 'S' tu≈üu</li>
                    </ol>
                </div>

                <div class="keyboard-shortcuts">
                    <h4>‚å®Ô∏è Kƒ±sayollar</h4>
                    <div class="shortcut">
                        <span>Sonraki G√∂rsel</span>
                        <span class="key">‚Üí</span>
                    </div>
                    <div class="shortcut">
                        <span>√ñnceki G√∂rsel</span>
                        <span class="key">‚Üê</span>
                    </div>
                    <div class="shortcut">
                        <span>Kaydet ve Devam</span>
                        <span class="key">S</span>
                    </div>
                    <div class="shortcut">
                        <span>Noktalarƒ± Sƒ±fƒ±rla</span>
                        <span class="key">R</span>
                    </div>
                    <div class="shortcut">
                        <span>G√∂r√ºn√ºrl√ºk</span>
                        <span class="key">V</span>
                    </div>
                    <div class="shortcut">
                        <span>Yakƒ±nla≈ütƒ±rmayƒ± Sƒ±fƒ±rla</span>
                        <span class="key">Z</span>
                    </div>
                    <div class="shortcut">
                        <span>Yakƒ±nla≈ütƒ±r</span>
                        <span class="key">Tekerlek</span>
                    </div>
                    <div class="shortcut">
                        <span>Kaydƒ±r</span>
                        <span class="key">Shift+S√ºr√ºkle</span>
                    </div>
                </div>

                <div style="margin-top: 20px;">
                    <h3 style="margin-bottom: 10px; color: #333;">üìÅ G√∂rseller</h3>
                    <ul class="image-list" id="imageList"></ul>
                </div>
            </div>

            <div class="canvas-area">
                <div class="controls">
                    <button class="btn-primary" onclick="prevImage()">‚Üê √ñnceki</button>
                    <button class="btn-primary" onclick="nextImage()">Sonraki ‚Üí</button>
                    
                    <button class="btn-warning" onclick="undoPoint()" style="background: #8b5cf6;">‚Ü©Ô∏è Geri Al</button>

                    <button class="btn-success" onclick="saveAnnotation()">üíæ Kaydet</button>
                    <button class="btn-warning" onclick="resetPoints()">‚Ü∫ Noktalarƒ± Sƒ±fƒ±rla</button>
                    <button class="btn-primary" onclick="resetZoom()">üîç Yakƒ±nla≈ütƒ±rmayƒ± Sƒ±fƒ±rla</button>
                    <button class="btn-danger" onclick="clearCanvas()">üóëÔ∏è Hepsini Temizle</button>
                </div>

                <div class="canvas-wrapper">
                    <canvas id="canvas"></canvas>
                </div>
            </div>
        </div>
    </div>

    <!-- Registration Modal -->
    <div class="modal" id="registrationModal">
        <div class="modal-content">
            <h2>üëã ƒ∞HA Etiketleme'ye Ho≈ü Geldiniz!</h2>
            <p style="margin-bottom: 20px; color: #666;">Ba≈ülamak i√ßin l√ºtfen adƒ±nƒ±zƒ± girin</p>
            <input type="text" id="nameInput" placeholder="Adƒ±nƒ±zƒ± girin" autofocus>
            <button class="btn-primary" onclick="registerUser()">Etiketlemeye Ba≈üla</button>
        </div>
    </div>

    <!-- Notification -->
    <div class="notification" id="notification"></div>

    <script>
        // Configuration
        const POINT_LABELS = ['Burun Ucu', 'Sol Kanat Ucu', 'Saƒü Kanat Ucu', 'Kuyruk', 'Kanat K√∂k√º', 'Dikey Dengeleyici'];
        const POINT_LABELS_EN = ['Nose Tip', 'Left Wing Tip', 'Right Wing Tip', 'Fuselage Tail', 'Wing Root', 'Vertical Stabilizer'];
        const POINT_COLORS = ['#ef4444', '#10b981', '#f59e0b', '#3b82f6', '#a855f7', '#ec4899']; // Red, Green, Yellow, Blue, Purple, Pink
        const POINT_RADIUS = 5; // Small radius for small UAVs

        // State
        let canvas, ctx;
        let images = [];
        let currentImageIndex = 0;
        let currentImage = null;
        let points = []; // Each point: {x, y, visible}
        let annotatorId = null;
        let annotatorName = null;
        let scale = 1;
        let offsetX = 0;
        let offsetY = 0;
        let selectedPointIndex = -1; // For visibility toggling
        let imageLocks = {}; // Track who is working on which image
        let currentImageLocked = false; // Is current image locked by us?
        let zoomLevel = 1.0; // Zoom factor (1.0 = no zoom)
        let panX = 0; // Pan offset X
        let panY = 0; // Pan offset Y
        let isPanning = false; // Is user currently panning?
        let lastMouseX = 0;
        let lastMouseY = 0;
        let currentSubfolder = ''; // Current selected subfolder

        // Initialize
        window.onload = function() {
            canvas = document.getElementById('canvas');
            ctx = canvas.getContext('2d');
            
            // Check if user is already registered
            const storedId = localStorage.getItem('annotatorId');
            const storedName = localStorage.getItem('annotatorName');
            
            if (storedId && storedName) {
                annotatorId = storedId;
                annotatorName = storedName;
                document.getElementById('userName').textContent = annotatorName;
                loadSubfolders();
                loadImages();
            } else {
                showRegistrationModal();
            }

            // Add keyboard shortcuts
            document.addEventListener('keydown', handleKeyPress);
            
            // Canvas click handler
            canvas.addEventListener('click', handleCanvasClick);
            
            // Canvas right-click handler for visibility toggle
            canvas.addEventListener('contextmenu', handleCanvasRightClick);
            
            // Mouse wheel zoom
            canvas.addEventListener('wheel', handleMouseWheel);
            
            // Middle mouse button pan
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('mouseleave', handleMouseUp);
        };

        function showRegistrationModal() {
            document.getElementById('registrationModal').style.display = 'flex';
            document.getElementById('nameInput').focus();
            
            document.getElementById('nameInput').addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    registerUser();
                }
            });
        }

        async function registerUser() {
            const name = document.getElementById('nameInput').value.trim();
            
            if (!name) {
                alert('L√ºtfen adƒ±nƒ±zƒ± girin!');
                return;
            }

            try {
                const response = await fetch('/api/register', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name: name })
                });

                const data = await response.json();
                annotatorId = data.annotator_id;
                annotatorName = data.name;

                localStorage.setItem('annotatorId', annotatorId);
                localStorage.setItem('annotatorName', annotatorName);

                document.getElementById('userName').textContent = annotatorName;
                document.getElementById('registrationModal').style.display = 'none';

                showNotification(`Ho≈ü geldiniz, ${annotatorName}! üéâ`);
                loadSubfolders();
                loadImages();
            } catch (error) {
                alert('Kayƒ±t hatasƒ±. L√ºtfen tekrar deneyin.');
                console.error(error);
            }
        }

        async function loadImages(subfolder = '') {
            currentSubfolder = subfolder;
            
            try {
                const url = subfolder ? `/api/images?subfolder=${encodeURIComponent(subfolder)}` : '/api/images';
                const response = await fetch(url);
                const data = await response.json();
                images = data.images;

                if (images.length === 0) {
                    alert(`${subfolder || 'ana klas√∂rde'} g√∂rsel bulunamadƒ±! L√ºtfen sunucu g√∂rseller klas√∂r√ºne g√∂rsel ekleyin.`);
                    return;
                }

                renderImageList();
                loadImage(0);
                updateProgress();
            } catch (error) {
                alert('G√∂rseller y√ºklenirken hata! Sunucunun √ßalƒ±≈ütƒ±ƒüƒ±ndan emin olun!');
                console.error(error);
            }
        }

        async function loadSubfolders() {
            try {
                const response = await fetch('/api/subfolders');
                const data = await response.json();
                
                const selector = document.getElementById('subfolderSelector');
                if (selector && data.subfolders) {
                    selector.innerHTML = '';
                    data.subfolders.forEach(folder => {
                        const option = document.createElement('option');
                        option.value = folder;
                        option.textContent = folder || 'All Images (Root)';
                        selector.appendChild(option);
                    });
                }
            } catch (error) {
                console.error('Error loading subfolders:', error);
            }
        }

        async function renderImageList() {
            const list = document.getElementById('imageList');
            list.innerHTML = '';

            // Fetch current locks
            try {
                const response = await fetch('/api/locks');
                imageLocks = await response.json();
            } catch (error) {
                console.error('Error fetching locks:', error);
            }

            images.forEach((img, index) => {
                const li = document.createElement('li');
                li.className = 'image-item';
                
                // Check if image is locked
                if (imageLocks[img]) {
                    const lockData = imageLocks[img];
                    if (lockData.annotator_id === annotatorId) {
                        // Locked by us
                        li.textContent = `üîí ${img} (Siz)`;
                        li.style.fontWeight = 'bold';
                    } else {
                        // Locked by someone else
                        li.textContent = `üîí ${img} (${lockData.annotator_name})`;
                        li.style.opacity = '0.6';
                        li.style.cursor = 'not-allowed';
                        li.onclick = () => {
                            showNotification(`‚ö†Ô∏è ${lockData.annotator_name} bu g√∂rsel √ºzerinde √ßalƒ±≈üƒ±yor!`);
                        };
                        list.appendChild(li);
                        return; // Skip normal onclick
                    }
                } else {
                    li.textContent = img;
                }
                
                li.onclick = () => loadImage(index);
                
                if (index === currentImageIndex) {
                    li.classList.add('active');
                }

                list.appendChild(li);
            });
            
            // Update annotation status (green borders) after rendering
            await updateAnnotationStatus();
        }

        async function loadImage(index) {
            if (index < 0 || index >= images.length) return;

            // Unlock previous image if we had it locked
            if (currentImageLocked && currentImageIndex >= 0) {
                await unlockImage(images[currentImageIndex]);
            }

            currentImageIndex = index;
            const imageName = images[index];

            // Try to lock the image
            try {
                const lockResponse = await fetch(`/api/lock/${imageName}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        annotator_id: annotatorId,
                        annotator_name: annotatorName
                    })
                });

                const lockData = await lockResponse.json();

                if (lockData.locked) {
                    // Image is locked by someone else
                    showNotification(`‚ö†Ô∏è ${lockData.locked_by} ≈üu anda bu g√∂rsel √ºzerinde √ßalƒ±≈üƒ±yor!`);
                    currentImageLocked = false;
                    // Don't load the image, go back to previous or next available
                    return;
                } else {
                    currentImageLocked = true;
                }
            } catch (error) {
                console.error('Error locking image:', error);
                currentImageLocked = false;
            }

            // Load existing annotation if any FIRST
            try {
                const response = await fetch(`/api/annotations/${imageName}`);
                const data = await response.json();

                if (data.exists !== false && data.points) {
                    // Load existing points with visibility
                    points = data.points.map(p => ({
                        x: p.x,
                        y: p.y,
                        visible: p.visible !== undefined ? p.visible : true
                    }));
                } else {
                    // Initialize empty points array
                    points = [];
                }
            } catch (error) {
                points = [];
            }

            // Load image AFTER loading annotation data
            currentImage = new Image();
            currentImage.onload = function() {
                resizeCanvas();
                drawImage(); // This will now draw the loaded points
                renderImageList(); // This calls updateAnnotationStatus internally
            };
            currentImage.src = `/api/image/${imageName}`;
        }

        async function unlockImage(imageName) {
            try {
                await fetch(`/api/unlock/${imageName}`, {
                    method: 'POST'
                });
            } catch (error) {
                console.error('Error unlocking image:', error);
            }
        }

        function resizeCanvas() {
            const wrapper = canvas.parentElement;
            const maxWidth = wrapper.clientWidth - 40;
            const maxHeight = wrapper.clientHeight - 40;

            const imgAspect = currentImage.width / currentImage.height;
            const containerAspect = maxWidth / maxHeight;

            if (imgAspect > containerAspect) {
                canvas.width = maxWidth;
                canvas.height = maxWidth / imgAspect;
            } else {
                canvas.height = maxHeight;
                canvas.width = maxHeight * imgAspect;
            }

            scale = canvas.width / currentImage.width;
            offsetX = 0;
            offsetY = 0;
        }

        function drawImage() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Save context state
            ctx.save();
            
            // Apply zoom and pan transformations
            ctx.translate(panX, panY);
            ctx.scale(zoomLevel, zoomLevel);
            
            // Draw the image
            // FIX: Removed "/ zoomLevel" from width and height
            ctx.drawImage(currentImage, 0, 0, canvas.width, canvas.height);

            // Draw points
            points.forEach((point, index) => {
                const x = (point.x * scale);
                const y = (point.y * scale);

                if (point.visible) {
                    // Draw visible point (solid)
                    ctx.beginPath();
                    // We keep "/ zoomLevel" here so the dots stay the same 
                    // visual size regardless of how much you zoom in
                    ctx.arc(x, y, POINT_RADIUS / zoomLevel, 0, 2 * Math.PI);
                    ctx.fillStyle = POINT_COLORS[index];
                    ctx.fill();
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 2 / zoomLevel;
                    ctx.stroke();

                    // Draw label
                    ctx.fillStyle = 'white';
                    ctx.strokeStyle = 'black';
                    ctx.lineWidth = 2 / zoomLevel;
                    ctx.font = `bold ${11 / zoomLevel}px Arial`;
                    ctx.strokeText(POINT_LABELS[index], x + 10 / zoomLevel, y - 6 / zoomLevel);
                    ctx.fillText(POINT_LABELS[index], x + 10 / zoomLevel, y - 6 / zoomLevel);
                } else {
                    // Draw invisible point (dashed circle with X)
                    ctx.beginPath();
                    ctx.arc(x, y, POINT_RADIUS / zoomLevel, 0, 2 * Math.PI);
                    ctx.strokeStyle = POINT_COLORS[index];
                    ctx.lineWidth = 2 / zoomLevel;
                    ctx.setLineDash([3 / zoomLevel, 3 / zoomLevel]);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    
                    // Draw X
                    ctx.strokeStyle = POINT_COLORS[index];
                    ctx.lineWidth = 2 / zoomLevel;
                    ctx.beginPath();
                    const crossSize = 4 / zoomLevel;
                    ctx.moveTo(x - crossSize, y - crossSize);
                    ctx.lineTo(x + crossSize, y + crossSize);
                    ctx.moveTo(x + crossSize, y - crossSize);
                    ctx.lineTo(x - crossSize, y + crossSize);
                    ctx.stroke();

                    // Draw label with "HIDDEN"
                    ctx.fillStyle = POINT_COLORS[index];
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 2 / zoomLevel;
                    ctx.font = `bold ${10 / zoomLevel}px Arial`;
                    ctx.strokeText(POINT_LABELS[index] + ' (Gƒ∞ZLƒ∞)', x + 10 / zoomLevel, y - 6 / zoomLevel);
                    ctx.fillText(POINT_LABELS[index] + ' (Gƒ∞ZLƒ∞)', x + 10 / zoomLevel, y - 6 / zoomLevel);
                }
            });

            // Draw lines connecting points if all are placed
            if (points.length === 6) {
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.lineWidth = 2 / zoomLevel;
                ctx.setLineDash([5 / zoomLevel, 5 / zoomLevel]);

                // Draw body line (nose to tail) - only if both visible
                if (points[0].visible && points[3].visible) {
                    ctx.beginPath();
                    ctx.moveTo(points[0].x * scale, points[0].y * scale);
                    ctx.lineTo(points[3].x * scale, points[3].y * scale);
                    ctx.stroke();
                }

                // Draw wing line (left to right) - only if both visible
                if (points[1].visible && points[2].visible) {
                    ctx.beginPath();
                    ctx.moveTo(points[1].x * scale, points[1].y * scale);
                    ctx.lineTo(points[2].x * scale, points[2].y * scale);
                    ctx.stroke();
                }
                
                // Draw wing root cross if visible
                if (points[4].visible) {
                    ctx.strokeStyle = POINT_COLORS[4];
                    ctx.lineWidth = 1 / zoomLevel;
                    ctx.setLineDash([]);
                    const crossSize = 8 / zoomLevel;
                    const cx = points[4].x * scale;
                    const cy = points[4].y * scale;
                    ctx.beginPath();
                    ctx.moveTo(cx - crossSize, cy);
                    ctx.lineTo(cx + crossSize, cy);
                    ctx.moveTo(cx, cy - crossSize);
                    ctx.lineTo(cx, cy + crossSize);
                    ctx.stroke();
                }
                
                ctx.setLineDash([]);
            }
            
            // Restore context state
            ctx.restore();
        }

        function handleCanvasClick(event) {
            const rect = canvas.getBoundingClientRect();
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;
            
            // Transform mouse coordinates to image space considering zoom and pan
            const clickX = ((mouseX - panX) / zoomLevel) / scale;
            const clickY = ((mouseY - panY) / zoomLevel) / scale;

            // Check if clicking near existing point to select it
            let clickedPointIndex = -1;
            const clickThreshold = 15 / (scale * zoomLevel); // Adjust threshold for zoom
            
            for (let i = 0; i < points.length; i++) {
                const dx = points[i].x - clickX;
                const dy = points[i].y - clickY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < clickThreshold) {
                    clickedPointIndex = i;
                    break;
                }
            }

            if (clickedPointIndex !== -1) {
                // Clicked on existing point - toggle visibility with V key or right-click
                selectedPointIndex = clickedPointIndex;
                showNotification(`${POINT_LABELS[clickedPointIndex]} se√ßildi. G√∂r√ºn√ºrl√ºƒü√º deƒüi≈ütirmek i√ßin V tu≈üuna basƒ±n veya saƒü tƒ±klayƒ±n.`);
                return;
            }

            // Not clicking on existing point - add new point if space available
            if (!currentImage || points.length >= 6) {
                if (points.length >= 6) {
                    showNotification('T√ºm 6 nokta yerle≈ütirildi! G√∂r√ºn√ºrl√ºƒü√º deƒüi≈ütirmek i√ßin noktaya saƒü tƒ±klayƒ±n.');
                }
                return;
            }

            // Add new point (default visible, except last point which defaults to false for Vertical Stabilizer)
            const defaultVisible = points.length < 5; // First 5 points visible by default, 6th (Vertical Stabilizer) hidden
            points.push({ x: clickX, y: clickY, visible: defaultVisible });
            drawImage();

            if (points.length === 6) {
                showNotification('T√ºm 6 nokta yerle≈ütirildi! Kaydetmek i√ßin S tu≈üuna basƒ±n. G√∂r√ºn√ºrl√ºƒü√º deƒüi≈ütirmek i√ßin saƒü tƒ±klayƒ±n.');
            } else if (points.length === 5) {
                showNotification('Son nokta: Dikey Dengeleyici (varsayƒ±lan: gizli). Varsa g√∂r√ºn√ºr yapƒ±n ve yerle≈ütirin.');
            }
        }

        function handleCanvasRightClick(event) {
            event.preventDefault(); // Prevent context menu
            
            const rect = canvas.getBoundingClientRect();
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;
            
            // Transform to image space
            const clickX = ((mouseX - panX) / zoomLevel) / scale;
            const clickY = ((mouseY - panY) / zoomLevel) / scale;

            // Find which point was clicked
            const clickThreshold = 15 / (scale * zoomLevel);
            
            for (let i = 0; i < points.length; i++) {
                const dx = points[i].x - clickX;
                const dy = points[i].y - clickY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < clickThreshold) {
                    // Toggle visibility
                    points[i].visible = !points[i].visible;
                    const status = points[i].visible ? 'G√ñR√úN√úR' : 'Gƒ∞ZLƒ∞';
                    showNotification(`${POINT_LABELS[i]} ${status} olarak i≈üaretlendi`);
                    drawImage();
                    return;
                }
            }
        }

        function handleMouseWheel(event) {
            event.preventDefault();
            
            const rect = canvas.getBoundingClientRect();
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;
            
            // Zoom factor
            const zoomFactor = event.deltaY < 0 ? 1.1 : 0.9;
            const newZoom = Math.max(0.5, Math.min(5.0, zoomLevel * zoomFactor));
            
            // Adjust pan to zoom towards mouse position
            const zoomRatio = newZoom / zoomLevel;
            panX = mouseX - (mouseX - panX) * zoomRatio;
            panY = mouseY - (mouseY - panY) * zoomRatio;
            
            zoomLevel = newZoom;
            drawImage();
        }

        function handleMouseDown(event) {
            if (event.button === 1 || (event.button === 0 && event.shiftKey)) {
                // Middle mouse button or Shift+Left click for panning
                event.preventDefault();
                isPanning = true;
                lastMouseX = event.clientX;
                lastMouseY = event.clientY;
                canvas.style.cursor = 'grabbing';
            }
        }

        function handleMouseMove(event) {
            if (isPanning) {
                const dx = event.clientX - lastMouseX;
                const dy = event.clientY - lastMouseY;
                
                panX += dx;
                panY += dy;
                
                lastMouseX = event.clientX;
                lastMouseY = event.clientY;
                
                drawImage();
            }
        }

        function handleMouseUp(event) {
            if (isPanning) {
                isPanning = false;
                canvas.style.cursor = 'crosshair';
            }
        }

        function resetZoom() {
            zoomLevel = 1.0;
            panX = 0;
            panY = 0;
            drawImage();
            showNotification('Yakƒ±nla≈ütƒ±rma sƒ±fƒ±rlandƒ±');
        }

        function resetPoints() {
            points = [];
            selectedPointIndex = -1;
            drawImage();
            showNotification('Noktalar sƒ±fƒ±rlandƒ±');
        }

        function clearCanvas() {
            points = [];
            selectedPointIndex = -1;
            drawImage();
        }

        function undoPoint() {
            if (points.length > 0) {
                // Remove the last added point
                points.pop();
                
                // Reset selection index to prevent errors
                selectedPointIndex = -1;
                
                // Redraw the canvas to update lines and dots
                drawImage();
                
                showNotification('Son nokta geri alƒ±ndƒ±');
            } else {
                showNotification('Geri alƒ±nacak nokta yok');
            }
        }

        async function saveAnnotation() {
            if (points.length !== 6) {
                alert('Kaydetmeden √∂nce l√ºtfen t√ºm 6 noktayƒ± yerle≈ütirin!');
                return;
            }

            const imageName = images[currentImageIndex];

            try {
                const response = await fetch('/api/annotate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        image_name: imageName,
                        annotator_id: annotatorId,
                        annotator_name: annotatorName,
                        points: points  // Includes x, y, visible for each point
                    })
                });

                if (response.ok) {
                    currentImageLocked = false; // Image is unlocked after save
                    showNotification('‚úì Etiket kaydedildi!');
                    updateProgress();
                    
                    // Move to next image
                    setTimeout(() => {
                        nextImage();
                    }, 500);
                }
            } catch (error) {
                alert('Etiket kaydedilirken hata! Sunucu baƒülantƒ±sƒ±nƒ± kontrol edin.');
                console.error(error);
            }
        }

        function nextImage() {
            if (currentImageIndex < images.length - 1) {
                loadImage(currentImageIndex + 1);
            } else {
                showNotification('üéâ Son g√∂rsele ula≈ütƒ±nƒ±z!');
            }
        }

        function prevImage() {
            if (currentImageIndex > 0) {
                loadImage(currentImageIndex - 1);
            }
        }

        function toggleVisibility() {
            if (selectedPointIndex >= 0 && selectedPointIndex < points.length) {
                points[selectedPointIndex].visible = !points[selectedPointIndex].visible;
                const status = points[selectedPointIndex].visible ? 'G√ñR√úN√úR' : 'Gƒ∞ZLƒ∞';
                showNotification(`${POINT_LABELS[selectedPointIndex]} ${status} olarak i≈üaretlendi`);
                drawImage();
            }
        }

        function handleKeyPress(event) {
            // Handle Ctrl+Z for Undo
            if ((event.ctrlKey || event.metaKey) && event.key.toLowerCase() === 'z') {
                event.preventDefault();
                undoPoint();
                return;
            }

            // Handle Backspace for Undo
            if (event.key === 'Backspace') {
                undoPoint();
                return;
            }

            // Existing shortcuts
            switch(event.key.toLowerCase()) {
                case 'arrowright':
                    nextImage();
                    break;
                case 'arrowleft':
                    prevImage();
                    break;
                case 's':
                    if (points.length === 6) {
                        saveAnnotation();
                    }
                    break;
                case 'r':
                    resetPoints();
                    break;
                case 'v':
                    toggleVisibility();
                    break;
                case 'z': 
                    // Note: Single 'z' is still Reset Zoom. 
                    // Ctrl+z is now Undo.
                    resetZoom();
                    break;
            }
        }

        async function updateProgress() {
            try {
                const response = await fetch('/api/stats');
                const data = await response.json();

                document.getElementById('totalCount').textContent = data.total_images;
                document.getElementById('annotatedCount').textContent = data.total_annotations;

                const percentage = data.total_images > 0 
                    ? Math.round((data.total_annotations / data.total_images) * 100)
                    : 0;

                document.getElementById('progressFill').style.width = percentage + '%';
                document.getElementById('progressFill').textContent = percentage + '%';

                // Update image list to show annotated images
                await updateAnnotationStatus();
            } catch (error) {
                console.error('Error updating progress:', error);
            }
        }

        async function updateAnnotationStatus() {
            // Check which images are annotated
            const listItems = document.querySelectorAll('.image-item');
            
            for (let i = 0; i < images.length; i++) {
                try {
                    const response = await fetch(`/api/annotations/${images[i]}`);
                    const data = await response.json();
                    
                    // Check if annotation exists AND has points
                    if (data.exists !== false && data.points && data.points.length > 0) {
                        listItems[i].classList.add('annotated');
                    } else {
                        listItems[i].classList.remove('annotated');
                    }
                } catch (error) {
                    // If there's an error, remove annotated class
                    listItems[i].classList.remove('annotated');
                }
            }
        }

        function showNotification(message) {
            const notification = document.getElementById('notification');
            notification.textContent = message;
            notification.style.display = 'block';

            setTimeout(() => {
                notification.style.display = 'none';
            }, 3000);
        }

        // Update progress every 10 seconds
        setInterval(updateProgress, 10000);
        
        // Refresh image list (to show locks) every 5 seconds
        setInterval(renderImageList, 5000);
        
        // Refresh our lock every 2 minutes to prevent timeout
        setInterval(async function() {
            if (currentImageLocked && currentImageIndex >= 0) {
                const imageName = images[currentImageIndex];
                try {
                    await fetch(`/api/lock/${imageName}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            annotator_id: annotatorId,
                            annotator_name: annotatorName
                        })
                    });
                } catch (error) {
                    console.error('Error refreshing lock:', error);
                }
            }
        }, 120000); // Every 2 minutes
        
        // Unlock image when user closes/leaves the page
        window.addEventListener('beforeunload', async function() {
            if (currentImageLocked && currentImageIndex >= 0) {
                const imageName = images[currentImageIndex];
                // Use sendBeacon for reliability on page unload
                const data = new Blob([JSON.stringify({})], { type: 'application/json' });
                navigator.sendBeacon(`/api/unlock/${imageName}`, data);
            }
        });
    </script>
</body>
</html>